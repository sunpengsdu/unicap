// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include "job_tracker/job_tracker_function.h"
#include "job_tracker/scheduler.h"

using namespace  ::ntu::cap;


int main(int argc, char **argv) {
    google::InitGoogleLogging(argv[0]);
    google::LogToStderr();

    NodeInfo::singleton()._master_port = 34000;
    NodeInfo::singleton()._hdfs_namenode = "BDP-00";
    NodeInfo::singleton()._hdfs_namenode_port = 9000;

    load_hdfs_file("/dataset/wikipedia_300GB", "s", "p");

    std::thread server_side_thread;
    server_side_thread = start_job_tracker(10);



    KeyPartition rrr;
    rrr.__set_partition_algo(KeyPartitionAlgo::HashingPartition);
    create_table("a", 10, rrr);
    create_cf("a", "a", StorageType::InMemoryKeyValue);

/*
    std::shared_ptr<Stage>stage_1 = std::shared_ptr<Stage>(new Stage());
    stage_1->set_function_name("hello_world");
    stage_1->non_src(100);
   // stage_2->set_dst("a", "a");
    Scheduler::singleton().push_back(stage_1);
*/
/*
    std::vector<std::string> row;
    std::vector<std::string> column;
    std::vector<std::string> value;
    row.push_back("a");
    row.push_back("b");
    column.push_back("1");
    column.push_back("2");
    value.push_back("a1");
    value.push_back("b2");
    Storage::vector_put("a", "a", 0, row, column, value);


    std::vector<std::string> return_value1;

    Storage::vector_get("a","a", 0, row, column, return_value1);

    for (uint64_t j=0; j<return_value1.size(); ++j) {
        std::cout << return_value1[j] << "\n";
    }
    std::vector<std::vector<std::string> > return_value2;

    Storage::scan_all("s", "p", 0, return_value2);

    for (uint64_t j=0; j<return_value2[0].size(); ++j) {
        std::cout << return_value2[0][j] << ":"
                  << return_value2[1][j] << "->"
                  << return_value2[2][j] << "\n";
    }
*/
// create_cf("a", "b", StorageType::CommonKeyValue);


// create_task()


// foo.compare_exchange_weak(&i, j, std::memory_order_release, std::memory_order_release);

// std::atomic::compare_exchange_weak(std::ref(0), 1, std::memory_order_release, std::memory_order_release);

    server_side_thread.join();
    return 0;
}

/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Unicap_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace ntu { namespace cap {

int _kKeyPartitionAlgoValues[] = {
  KeyPartitionAlgo::Hashing,
  KeyPartitionAlgo::Range
};
const char* _kKeyPartitionAlgoNames[] = {
  "Hashing",
  "Range"
};
const std::map<int, const char*> _KeyPartitionAlgo_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kKeyPartitionAlgoValues, _kKeyPartitionAlgoNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


KeyPartition::~KeyPartition() throw() {
}


void KeyPartition::__set_partition_algo(const KeyPartitionAlgo::type val) {
  this->partition_algo = val;
}

void KeyPartition::__set_key_to_shard(const std::map<int64_t, int64_t> & val) {
  this->key_to_shard = val;
__isset.key_to_shard = true;
}

const char* KeyPartition::ascii_fingerprint = "652978FE52A8D7F6DACE48CF7F5C13D0";
const uint8_t KeyPartition::binary_fingerprint[16] = {0x65,0x29,0x78,0xFE,0x52,0xA8,0xD7,0xF6,0xDA,0xCE,0x48,0xCF,0x7F,0x5C,0x13,0xD0};

uint32_t KeyPartition::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_partition_algo = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->partition_algo = (KeyPartitionAlgo::type)ecast0;
          isset_partition_algo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->key_to_shard.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              int64_t _key6;
              xfer += iprot->readI64(_key6);
              int64_t& _val7 = this->key_to_shard[_key6];
              xfer += iprot->readI64(_val7);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.key_to_shard = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_partition_algo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t KeyPartition::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("KeyPartition");

  xfer += oprot->writeFieldBegin("partition_algo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->partition_algo);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.key_to_shard) {
    xfer += oprot->writeFieldBegin("key_to_shard", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->key_to_shard.size()));
      std::map<int64_t, int64_t> ::const_iterator _iter8;
      for (_iter8 = this->key_to_shard.begin(); _iter8 != this->key_to_shard.end(); ++_iter8)
      {
        xfer += oprot->writeI64(_iter8->first);
        xfer += oprot->writeI64(_iter8->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(KeyPartition &a, KeyPartition &b) {
  using ::std::swap;
  swap(a.partition_algo, b.partition_algo);
  swap(a.key_to_shard, b.key_to_shard);
  swap(a.__isset, b.__isset);
}

KeyPartition::KeyPartition(const KeyPartition& other9) {
  partition_algo = other9.partition_algo;
  key_to_shard = other9.key_to_shard;
  __isset = other9.__isset;
}
KeyPartition& KeyPartition::operator=(const KeyPartition& other10) {
  partition_algo = other10.partition_algo;
  key_to_shard = other10.key_to_shard;
  __isset = other10.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const KeyPartition& obj) {
  using apache::thrift::to_string;
  out << "KeyPartition(";
  out << "partition_algo=" << to_string(obj.partition_algo);
  out << ", " << "key_to_shard="; (obj.__isset.key_to_shard ? (out << to_string(obj.key_to_shard)) : (out << "<null>"));
  out << ")";
  return out;
}


TaskTrackerInfo::~TaskTrackerInfo() throw() {
}


void TaskTrackerInfo::__set_host_name(const std::string& val) {
  this->host_name = val;
}

void TaskTrackerInfo::__set_port(const int64_t val) {
  this->port = val;
}

const char* TaskTrackerInfo::ascii_fingerprint = "1CCCF6FC31CFD1D61BBBB1BAF3590620";
const uint8_t TaskTrackerInfo::binary_fingerprint[16] = {0x1C,0xCC,0xF6,0xFC,0x31,0xCF,0xD1,0xD6,0x1B,0xBB,0xB1,0xBA,0xF3,0x59,0x06,0x20};

uint32_t TaskTrackerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_host_name = false;
  bool isset_port = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host_name);
          isset_host_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->port);
          isset_port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_host_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_port)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TaskTrackerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TaskTrackerInfo");

  xfer += oprot->writeFieldBegin("host_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TaskTrackerInfo &a, TaskTrackerInfo &b) {
  using ::std::swap;
  swap(a.host_name, b.host_name);
  swap(a.port, b.port);
}

TaskTrackerInfo::TaskTrackerInfo(const TaskTrackerInfo& other11) {
  host_name = other11.host_name;
  port = other11.port;
}
TaskTrackerInfo& TaskTrackerInfo::operator=(const TaskTrackerInfo& other12) {
  host_name = other12.host_name;
  port = other12.port;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TaskTrackerInfo& obj) {
  using apache::thrift::to_string;
  out << "TaskTrackerInfo(";
  out << "host_name=" << to_string(obj.host_name);
  out << ", " << "port=" << to_string(obj.port);
  out << ")";
  return out;
}


TableProperty::~TableProperty() throw() {
}


void TableProperty::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void TableProperty::__set_table_type(const std::string& val) {
  this->table_type = val;
}

void TableProperty::__set_shard_num(const int64_t val) {
  this->shard_num = val;
}

void TableProperty::__set_shard_id_in_charge(const std::vector<int64_t> & val) {
  this->shard_id_in_charge = val;
}

void TableProperty::__set_all_shard_location(const std::map<int64_t, int64_t> & val) {
  this->all_shard_location = val;
}

void TableProperty::__set_key_partition(const KeyPartition& val) {
  this->key_partition = val;
}

const char* TableProperty::ascii_fingerprint = "74A6098C9F090F065DDB85EB7445B842";
const uint8_t TableProperty::binary_fingerprint[16] = {0x74,0xA6,0x09,0x8C,0x9F,0x09,0x0F,0x06,0x5D,0xDB,0x85,0xEB,0x74,0x45,0xB8,0x42};

uint32_t TableProperty::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_table_name = false;
  bool isset_table_type = false;
  bool isset_shard_num = false;
  bool isset_shard_id_in_charge = false;
  bool isset_all_shard_location = false;
  bool isset_key_partition = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          isset_table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_type);
          isset_table_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->shard_num);
          isset_shard_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->shard_id_in_charge.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->shard_id_in_charge.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += iprot->readI64(this->shard_id_in_charge[_i17]);
            }
            xfer += iprot->readListEnd();
          }
          isset_shard_id_in_charge = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->all_shard_location.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _ktype19;
            ::apache::thrift::protocol::TType _vtype20;
            xfer += iprot->readMapBegin(_ktype19, _vtype20, _size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              int64_t _key23;
              xfer += iprot->readI64(_key23);
              int64_t& _val24 = this->all_shard_location[_key23];
              xfer += iprot->readI64(_val24);
            }
            xfer += iprot->readMapEnd();
          }
          isset_all_shard_location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->key_partition.read(iprot);
          isset_key_partition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_table_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_table_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_shard_num)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_shard_id_in_charge)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_all_shard_location)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_key_partition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TableProperty::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("TableProperty");

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_num", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->shard_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shard_id_in_charge", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->shard_id_in_charge.size()));
    std::vector<int64_t> ::const_iterator _iter25;
    for (_iter25 = this->shard_id_in_charge.begin(); _iter25 != this->shard_id_in_charge.end(); ++_iter25)
    {
      xfer += oprot->writeI64((*_iter25));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("all_shard_location", ::apache::thrift::protocol::T_MAP, 5);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->all_shard_location.size()));
    std::map<int64_t, int64_t> ::const_iterator _iter26;
    for (_iter26 = this->all_shard_location.begin(); _iter26 != this->all_shard_location.end(); ++_iter26)
    {
      xfer += oprot->writeI64(_iter26->first);
      xfer += oprot->writeI64(_iter26->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("key_partition", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->key_partition.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(TableProperty &a, TableProperty &b) {
  using ::std::swap;
  swap(a.table_name, b.table_name);
  swap(a.table_type, b.table_type);
  swap(a.shard_num, b.shard_num);
  swap(a.shard_id_in_charge, b.shard_id_in_charge);
  swap(a.all_shard_location, b.all_shard_location);
  swap(a.key_partition, b.key_partition);
}

TableProperty::TableProperty(const TableProperty& other27) {
  table_name = other27.table_name;
  table_type = other27.table_type;
  shard_num = other27.shard_num;
  shard_id_in_charge = other27.shard_id_in_charge;
  all_shard_location = other27.all_shard_location;
  key_partition = other27.key_partition;
}
TableProperty& TableProperty::operator=(const TableProperty& other28) {
  table_name = other28.table_name;
  table_type = other28.table_type;
  shard_num = other28.shard_num;
  shard_id_in_charge = other28.shard_id_in_charge;
  all_shard_location = other28.all_shard_location;
  key_partition = other28.key_partition;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const TableProperty& obj) {
  using apache::thrift::to_string;
  out << "TableProperty(";
  out << "table_name=" << to_string(obj.table_name);
  out << ", " << "table_type=" << to_string(obj.table_type);
  out << ", " << "shard_num=" << to_string(obj.shard_num);
  out << ", " << "shard_id_in_charge=" << to_string(obj.shard_id_in_charge);
  out << ", " << "all_shard_location=" << to_string(obj.all_shard_location);
  out << ", " << "key_partition=" << to_string(obj.key_partition);
  out << ")";
  return out;
}

}} // namespace
